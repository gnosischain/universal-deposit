// SPDX-License-Identifier: MIT
pragma solidity 0.8.22;

import {UniversalDepositAccount} from './UniversalDepositAccount.sol';
import {ERC1967Proxy} from '@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol';

/**
 * @title ProxyFactory
 * @author gnosis
 * @notice Factory contract that deploys UniversalDepositAccount instances as upgradeable proxies
 * @dev Uses CREATE2 for deterministic addresses and minimal proxy pattern for gas efficiency.
 *      Each unique combination of (owner, recipient, destinationChainId) generates a unique account.
 */
contract ProxyFactory {
  /// @notice The UniversalDepositAccount implementation contract address
  address public immutable IMPLEMENTATION;

  /// @notice The UniversalDepositManager contract address used for all accounts
  address public immutable UD_MANAGER;

  /// @notice revert when UniversalDepositAccount proxy deployment fail
  error UDADeploymentFailed();

  /// @notice emit when UniversalDepositAccount proxy deployment success
  event UDACreated(address indexed UD);
  /**
   * @notice Initializes the factory with implementation and manager addresses
   * @param _implementation The UniversalDepositAccount implementation contract
   * @param _udManager The UniversalDepositManager contract for routing configurations
   */

  constructor(address _implementation, address _udManager) {
    IMPLEMENTATION = _implementation;
    UD_MANAGER = _udManager;
  }

  /**
   * @notice Deploys a new UniversalDepositAccount proxy with deterministic address
   * @dev Uses CREATE2 with salt derived from the three parameters for deterministic deployment.
   *      Each unique combination of parameters will always generate the same address.
   * @param _owner The address that will own the deposit account
   * @param _recipient The address that will receive bridged tokens on the destination chain
   * @param _destinationChainId The destination chain ID for token bridging
   * @return address The address of the newly deployed proxy contract
   */
  function createUniversalAccount(
    address _owner,
    address _recipient,
    uint256 _destinationChainId
  ) external returns (address) {
    bytes memory data = abi.encodeWithSelector(
      UniversalDepositAccount.initialize.selector, _owner, _recipient, _destinationChainId, UD_MANAGER
    );
    bytes32 salt;
    assembly {
      let ptr := mload(0x40)
      mstore(ptr, _recipient)
      mstore(add(ptr, 0x20), _owner)
      mstore(add(ptr, 0x40), _destinationChainId)
      salt := keccak256(ptr, 0x60)
    }
    address proxy = address(new ERC1967Proxy{salt: salt}(IMPLEMENTATION, data));
    if (proxy == address(0)) {
      revert UDADeploymentFailed();
    } else {
      emit UDACreated(proxy);
    }
    return proxy;
  }

  /**
   * @notice Computes the deterministic address for a UniversalDepositAccount proxy
   * @dev Calculates the address that would be generated by createUniversalAccount without deploying.
   *      Useful for off-chain address prediction and verification.
   * @param _owner The owner address used in the salt calculation
   * @param _recipient The recipient address used in the salt calculation
   * @param _destinationChainId The destination chain ID used in the salt calculation
   * @return address The predicted address of the proxy contract
   */
  function getUniversalAccount(
    address _owner,
    address _recipient,
    uint256 _destinationChainId
  ) external view returns (address) {
    bytes memory data = abi.encodeWithSelector(
      UniversalDepositAccount.initialize.selector, _owner, _recipient, _destinationChainId, UD_MANAGER
    );
    bytes32 salt;
    assembly {
      let ptr := mload(0x40)
      mstore(ptr, _recipient)
      mstore(add(ptr, 0x20), _owner)
      mstore(add(ptr, 0x40), _destinationChainId)
      salt := keccak256(ptr, 0x60)
    }

    bytes32 creationCodeHash =
      keccak256(abi.encodePacked(type(ERC1967Proxy).creationCode, abi.encode(IMPLEMENTATION, data)));

    bytes32 proxyHash = keccak256(abi.encodePacked(bytes1(0xff), address(this), salt, creationCodeHash));

    return address(uint160(uint256(proxyHash)));
  }
}
